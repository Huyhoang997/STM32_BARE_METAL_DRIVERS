/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2026 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "stm32f401xx.h"
#include "timer.h"
#include <string.h>

GPIO_Config_t led_blink = {
		.GPIO_MODE = GPIO_MODE_ALT,
		.GPIO_PIN = GPIO_PIN_1,
		.GPIO_OUT_TYPE = GPIO_OUTPUT_PUSH_PULL,
		.GPIO_PUPD = GPIO_PULL_UP,
		.GPIO_ALT_MODE = GPIO_ALT_1
};

GPIO_Config_t led_blink1 = {
		.GPIO_MODE = GPIO_MODE_OUTPUT,
		.GPIO_PIN = GPIO_PIN_0,
		.GPIO_OUT_TYPE = GPIO_OUTPUT_PUSH_PULL,
		.GPIO_PUPD = GPIO_PULL_UP
};

GPIO_Config_t button_state = {
		.GPIO_MODE = GPIO_MODE_INPUT,
		.GPIO_PIN = GPIO_PIN_0,
		.GPIO_PUPD = GPIO_PULL_UP,
		.GPIO_IT_TRIGGER_MODE = GPIO_IT_FALLING_RAISING
};

GPIO_Config_t uart_tx_gpio = {
		.GPIO_MODE = GPIO_MODE_ALT,
		.GPIO_PIN = GPIO_PIN_9,
		.GPIO_ALT_MODE = GPIO_ALT_7,
		.GPIO_OUT_SPEED = GPIO_HIGH_SPEED,
		.GPIO_OUT_TYPE = GPIO_OUTPUT_PUSH_PULL,
};

GPIO_Config_t uart_rx_gpio = {
		.GPIO_MODE = GPIO_MODE_ALT,
		.GPIO_PIN = GPIO_PIN_10,
		.GPIO_ALT_MODE = GPIO_ALT_7,
		.GPIO_OUT_SPEED = GPIO_HIGH_SPEED,
		.GPIO_OUT_TYPE = GPIO_OUTPUT_PUSH_PULL,
};

TIMER_Config_t timer_config  = {
		.AutoReload = 20000,
		.ClockDivision = CLOCK_DIVINE_BY_2,
		.CounterMode = COUNTER_MODE_UP,
		.Prescaler = 15,
		.is_enable_OnePulse = false,
		.UpdateSource = TIMER_UPDATE_COUNTER_ONLY,
		.is_enable_Preload = false,
		.CounterValue = 0
};

TIMER_OC_Config_t pwm_config = {
		.OutputCompareMode = OC1M_PWM_MODE_1,
		.is_fast_mode = true
};

USART_Config_t usart_config = {
		.Baudrate = 9600,
		.WordLength = DATA_8_BIT,
		.OverSamplingMode = USART_OVERSAMPLING_BY_16,
		.TransferMode = USART_TX_RX,
		.ParityType = USART_NONE_PARITY,
		.type = STOP_BIT_1
};

uint8_t servo_test[101] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
    30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
    40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
    50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
    60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
    70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
    80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
    90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
    100
};
uint32_t result = 0;
char xinchao[] = "Hello_World!";
uint8_t received_buf[13];


volatile uint32_t timer_count = 0;
volatile uint32_t button_count = 0;

/* Timer interrupt */
void TIM2_IRQHandler(void)
{
    if(TIMER2->SR & (1U << 0))
    {
        TIMER2->SR &= ~(1U << 0);
        GPIO_PinOutToggle(GPIOA, GPIO_PIN_1);
    }
}

/* Button interrupt */
void EXTI0_IRQHandler(void)
{
    if(EXTI->PR & (1U << 0))
    {
        EXTI->PR = (1U << 0);
        //GPIO_PinOutToggle(GPIOA, GPIO_PIN_0);  // LED khÃ¡c
    }
}

int main(void)
{
	TIMER_Status_Typedef timer_status;
	RCC_Status_Typedef rcc_status = RCC_InitSystemClock(RCC_CLOCK_16MHZ);
	(void)rcc_status;  // Suppress unused variable warning
	SYS_InitTick();
    GPIO_Init_Mode(GPIOA, &led_blink);
    GPIO_Init_Mode(GPIOA, &led_blink1);
    timer_status = TIMER_Base_Init(TIMER2, &timer_config);
    if(timer_status != TIMER_OK)
    {
    	GPIO_PinOutSet(GPIOA, GPIO_PIN_0);
    }
    TIMER_OC_Config(TIMER2, TIMER_CHANNEL_2, &pwm_config);
    GPIO_Init_IT(GPIOB, &button_state, 1);
    GPIO_Init_Mode(GPIOA, &uart_tx_gpio);
	GPIO_Init_Mode(GPIOA, &uart_rx_gpio);
    USART_Init(USART1, &usart_config);
    USART_Transmit(USART1, (uint8_t *)xinchao, 12);
	//USART_Receive(USART1, received_buf, 12);
    //result = TIMER2->ARR;
    TIMER_Start(TIMER2);

	for(;;)
	{
		USART_Receive(USART1, received_buf, 13, 1000);
		if(strcmp((char*)received_buf, "Servo_quay_90") == 0)
		{
    		TIMER_PWM_SetDutyPercent(TIMER2, TIMER_CHANNEL_2, 5);
		}
		if(strcmp((char*)received_buf, "Servo_quay_18") == 0)
		{
    		TIMER_PWM_SetDutyPercent(TIMER2, TIMER_CHANNEL_2, 8);
		}
		if(strcmp((char*)received_buf, "Servo_quay_00") == 0)
		{
    		TIMER_PWM_SetDutyPercent(TIMER2, TIMER_CHANNEL_2, 10);
		}

	}
}
